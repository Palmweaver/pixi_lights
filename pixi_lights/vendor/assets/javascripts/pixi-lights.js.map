{"version":3,"file":"pixi-lights.js","sources":["../src/mixins/Circle.js","../src/main.js","../src/lights/light/Light.js","../src/lights/light/LightShader.js","../src/lights/ambientLight/AmbientLight.js","../src/lights/ambientLight/AmbientLightShader.js","../src/lights/pointLight/PointLight.js","../src/lights/pointLight/point.frag.js","../src/lights/pointLight/PointLightShader.js","../src/lights/directionalLight/DirectionalLight.js","../src/lights/directionalLight/directional.frag.js","../src/lights/directionalLight/DirectionalLightShader.js","../src/renderers/LightRenderer.js","../src/lights/wireframe/WireframeShader.js"],"sourcesContent":["/**\n * Contains mixins for the `PIXI.Circle` class.\n * @class Circle\n * @memberof PIXI\n * @see http://pixijs.download/release/docs/PIXI.Circle.html\n */\n/**\n * Creates vertices and indices arrays to describe this circle.\n * @method PIXI.Circle#getMesh\n * @param [totalSegments=40] {number} Total segments to build for the circle mesh.\n * @param [verticesOutput] {Float32Array} An array to output the vertices into. Length must be\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\n * @param [indicesOutput] {Uint16Array} An array to output the indices into, in gl.TRIANGLE_FAN format. Length must\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\n * @return {PIXI.Circle~MeshData} Object with verticies and indices arrays\n */\nPIXI.Circle.prototype.getMesh = function getMesh(totalSegments = 40, vertices, indices) {\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\n    indices = indices || new Uint16Array(totalSegments + 1);\n\n    let seg = (Math.PI * 2) / totalSegments,\n        indicesIndex = -1;\n\n    indices[++indicesIndex] = indicesIndex;\n\n    for (let i = 0; i <= totalSegments; ++i) {\n        let index = i*2;\n        let angle = seg * i;\n\n        vertices[index] = Math.cos(angle) * this.radius;\n        vertices[index+1] = Math.sin(angle) * this.radius;\n\n        indices[++indicesIndex] = indicesIndex;\n    }\n\n    indices[indicesIndex] = 1;\n\n    return { vertices, indices };\n};\n\n/**\n * @typedef PIXI.Circle~MeshData\n * @property {Float32Array} vertices - Vertices data\n * @property {Uint16Array} indices - Indices data\n */\n","/**\n * @namespace PIXI.lights\n */\n\n/**\n * @static\n * @memberof PIXI.lights\n * @member {Object}\n */\nconst plugins = {};\n\n/**\n * @static\n * @memberof PIXI.lights\n * @member {PIXI.display.Group}\n */\nconst diffuseGroup = new PIXI.display.Group();\n\n/**\n * @static\n * @memberof PIXI.lights\n * @member {PIXI.display.Group}\n */\nconst normalGroup = new PIXI.display.Group();\n\n/**\n * @static\n * @memberof PIXI.lights\n * @member {PIXI.display.Group}\n */\nconst lightGroup = new PIXI.display.Group();\n\ndiffuseGroup.useRenderTexture = true;\nnormalGroup.useRenderTexture = true;\n\n/**\n * @static\n * @memberof PIXI.lights\n * @param {string} name - Name of the plugin\n * @param {class} classRef - Class references\n */\nfunction registerPlugin(name, classRef) {\n    plugins[name] = classRef;\n}\n\nexport {\n    plugins,\n    diffuseGroup,\n    normalGroup,\n    lightGroup,\n    registerPlugin\n};\n","import {lightGroup} from '../../main';\n\n/**\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The brightness of the light, in range [0, 1].\n */\nexport default class Light extends PIXI.Container {\n    constructor(color, brightness, vertices, indices) {\n        super();\n\n        /**\n         * An array of vertices\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = vertices || new Float32Array(8);\n\n        /**\n         * An array containing the indices of the vertices\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = indices || new Uint16Array([0,1,2, 0,2,3]);\n\n        /**\n         * The blend mode to be applied to the light.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.ADD\n         * @see http://pixijs.download/release/docs/PIXI.html#.BLEND_MODES\n         */\n        this.blendMode = PIXI.BLEND_MODES.ADD;\n\n        /**\n         * The draw mode to be applied to the light geometry.\n         *\n         * @member {number}\n         * @default PIXI.DRAW_MODES.TRIANGLES\n         * @see http://pixijs.download/release/docs/PIXI.html#.DRAW_MODES\n         */\n        this.drawMode = PIXI.DRAW_MODES.TRIANGLES;\n\n        /**\n         * When incremented the renderer will re-upload indices\n         *\n         * @member {number}\n         */\n        this.dirty = 0;\n\n        /**\n         * The height of the light from the viewport.\n         *\n         * @member {number}\n         * @default 0.075\n         */\n        this.lightHeight = 0.075;\n\n        /**\n         * The falloff attenuation coeficients.\n         *\n         * @member {number[]}\n         * @default [0.75, 3, 20]\n         */\n        this.falloff = [0.75, 3, 20];\n\n        /**\n         * The name of the shader plugin to use.\n         *\n         * @member {string}\n         */\n        this.shaderName = null;\n\n        /**\n         * By default the light uses a viewport sized quad as the mesh.\n         */\n        this.useViewportQuad = true;\n\n        // color and brightness are exposed through setters\n        this._color = 0x4d4d59;\n        this._colorRgba = [0.3, 0.3, 0.35, 0.8];\n\n        // run the color setter\n        if (color || color === 0) {\n            this.color = color;\n        }\n\n        // run the brightness setter\n        if (brightness || brightness === 0) {\n            this.brightness = brightness;\n        }\n\n        this.parentGroup = lightGroup;\n\n\n        /**\n         * WebGL data for this light\n         * @member {Object}\n         * @private\n         */\n        this._glDatas = {};\n\n        this.shaderName = 'lights';\n    }\n\n    /**\n     * The color of the lighting.\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    get color() {\n        return this._color;\n    }\n    set color(val) {\n        this._color = val;\n        PIXI.utils.hex2rgb(val, this._colorRgba);\n    }\n\n    /**\n     * The brightness of this lighting. Normalized in the range [0, 1].\n     *\n     * @member {number}\n     * @memberof Light#\n     */\n    get brightness() {\n        return this._colorRgba[3];\n    }\n    set brightness(val) {\n        this._colorRgba[3] = val;\n    }\n\n    syncShader(shader) {\n        shader.uniforms.uUseViewportQuad = this.useViewportQuad;\n\n        let uLightColor = shader.uniforms.uLightColor;\n        if (uLightColor) {\n            uLightColor[0] = this._colorRgba[0];\n            uLightColor[1] = this._colorRgba[1];\n            uLightColor[2] = this._colorRgba[2];\n            uLightColor[3] = this._colorRgba[3];\n            shader.uniforms.uLightColor = uLightColor;\n        }\n\n        shader.uniforms.uLightHeight = this.lightHeight;\n\n        let uLightFalloff = shader.uniforms.uLightFalloff;\n        if (uLightFalloff) {\n            uLightFalloff[0] = this.falloff[0];\n            uLightFalloff[1] = this.falloff[1];\n            uLightFalloff[2] = this.falloff[2];\n            shader.uniforms.uLightFalloff = uLightFalloff;\n        }\n    }\n\n    _renderWebGL(renderer) {\n        renderer.setObjectRenderer(renderer.plugins.lights);\n        renderer.plugins.lights.render(this);\n    }\n}\n","import vertex from './light.vert';\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class LightShader extends PIXI.Shader {\n    constructor(gl, vertexSrc, fragmentSrc, customUniforms, customAttributes) {\n        const uniforms = {\n            translationMatrix:  { type: 'mat3', value: new Float32Array(9) },\n            projectionMatrix:   { type: 'mat3', value: new Float32Array(9) },\n\n            // textures from the previously rendered FBOs\n            uSampler:       { type: 'sampler2D', value: null },\n            uNormalSampler: { type: 'sampler2D', value: null },\n\n            // should we apply the translation matrix or not.\n            uUseViewportQuad: { type: 'bool', value: true },\n\n            // size of the renderer viewport\n            uViewSize:      { type: '2f', value: new Float32Array(2) },\n\n            // light color, alpha channel used for intensity.\n            uLightColor:    { type: '4f', value: new Float32Array([1, 1, 1, 1]) },\n\n            // light falloff attenuation coefficients\n            uLightFalloff:  { type: '3f', value: new Float32Array([0, 0, 0]) },\n\n            // height of the light above the viewport\n            uLightHeight: { type: '1f', value: 0.075 }\n        };\n\n        if (customUniforms) {\n            for (const u in customUniforms) {\n                uniforms[u] = customUniforms[u];\n            }\n        }\n\n        const attributes = {\n            aVertexPosition: 0\n        };\n\n        if (customAttributes) {\n            for (const a in customAttributes) {\n                attributes[a] = customAttributes[a];\n            }\n        }\n\n        super(gl, vertexSrc || LightShader.defaultVertexSrc, fragmentSrc, attributes);\n    }\n}\n\n/**\n * @static\n * @member {string}\n */\nLightShader.defaultVertexSrc = vertex;\n","import Light from '../light/Light';\n\n/**\n * Ambient light is drawn using a full-screen quad\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=0.5] {number} The brightness of the light.\n */\nexport default class AmbientLight extends Light {\n    constructor(color=0xFFFFFF, brightness=0.5) {\n        super(color, brightness);\n        this.shaderName = 'ambientLightShader';\n    }\n}\n","import {registerPlugin} from '../../main';\nimport LightShader from '../light/LightShader';\nimport fragment from './ambient.frag';\n\n/**\n * @class\n * @extends PIXI.lights.LightShader\n * @memberof PIXI.lights\n * @param gl {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class AmbientLightShader extends LightShader {\n    constructor(gl) {\n        super(gl, null, fragment);\n    }\n}\n\nregisterPlugin('ambientLightShader', AmbientLightShader);\n","import Light from '../light/Light';\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [radius=Infinity] {number} The distance the light reaches. You will likely need\n *  to change the falloff of the light as well if you change this value. Infinity will\n *  use the entire viewport as the drawing surface.\n */\nexport default class PointLight extends Light {\n    constructor(color=0xFFFFFF, brightness=1, radius=Infinity) {\n        if (radius !== Infinity) {\n            const shape = new PIXI.Circle(0, 0, radius);\n            const {vertices, indices} = shape.getMesh();\n\n            super(color, brightness, vertices, indices);\n\n            this.useViewportQuad = false;\n            this.drawMode = PIXI.DRAW_MODES.TRIANGLE_FAN;\n        }\n        else {\n            super(color, brightness);\n        }\n        this.radius = radius;\n        this.shaderName = 'pointLightShader';\n    }\n\n    syncShader(shader) {\n        super.syncShader(shader);\n        shader.uniforms.uLightRadius = this.radius;\n    }\n}\n","import commonUniforms from '../shared/commonUniforms.glsl';\nimport computeVertexPosition from '../shared/computeVertexPosition.glsl';\nimport loadNormals from '../shared/loadNormals.glsl';\nimport computeDiffuse from '../shared/computeDiffuse.glsl';\nimport combine from '../shared/combine.glsl';\n\nexport default `precision highp float;\n\n// imports the common uniforms like samplers, and ambient color\n${commonUniforms}\n\nuniform float uLightRadius;\n\nvoid main()\n{\n${computeVertexPosition}\n${loadNormals}\n\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\n\n    // correct for aspect ratio\n    lightVector.x *= uViewSize.x / uViewSize.y;\n\n    // compute Distance\n    float D = length(lightVector);\n\n    // bail out early when pixel outside of light sphere\n    if (D > uLightRadius) discard;\n\n${computeDiffuse}\n\n    // calculate attenuation\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\n\n${combine}\n}\n`;\n","import {registerPlugin} from '../../main';\nimport LightShader from '../light/LightShader';\nimport fragment from './point.frag';\n\n/**\n * @class\n * @extends PIXI.lights.LightShader\n * @memberof PIXI.lights\n * @param gl {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class PointLightShader extends LightShader {\n    constructor(gl) {\n        super(gl, null, fragment, {\n            // height of the light above the viewport\n            uLightRadius: {\n                type: '1f',\n                value: 1\n            }\n        });\n    }\n}\n\nregisterPlugin('pointLightShader', PointLightShader);\n","import Light from '../light/Light';\n\n/**\n * @class\n * @extends PIXI.lights.Light\n * @memberof PIXI.lights\n *\n * @param [color=0xFFFFFF] {number} The color of the light.\n * @param [brightness=1] {number} The intensity of the light.\n * @param [target] {PIXI.DisplayObject|PIXI.Point} The object in the scene to target.\n */\nexport default class DirectionalLight extends Light {\n    constructor(color=0xFFFFFF, brightness=1, target) {\n        super(color, brightness);\n\n        this.target = target;\n        this._directionVector = new PIXI.Point();\n        this.shaderName = 'directionalLightShader';\n    }\n\n    updateTransform() {\n        this.containerUpdateTransform();\n\n        let vec = this._directionVector,\n            wt = this.worldTransform,\n            tx = this.target.worldTransform ? this.target.worldTransform.tx : this.target.x,\n            ty = this.target.worldTransform ? this.target.worldTransform.ty : this.target.y;\n\n        // calculate direction from this light to the target\n        vec.x = wt.tx - tx;\n        vec.y = wt.ty - ty;\n\n        // normalize\n        const len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n        vec.x /= len;\n        vec.y /= len;\n    }\n\n    syncShader(shader) {\n        super.syncShader(shader);\n\n        const uLightDirection = shader.uniforms.uLightDirection;\n        uLightDirection[0] = this._directionVector.x;\n        uLightDirection[1] = this._directionVector.y;\n        shader.uniforms.uLightDirection = uLightDirection;\n    }\n}\n","import commonUniforms from '../shared/commonUniforms.glsl';\nimport computeVertexPosition from '../shared/computeVertexPosition.glsl';\nimport loadNormals from '../shared/loadNormals.glsl';\nimport computeDiffuse from '../shared/computeDiffuse.glsl';\nimport combine from '../shared/combine.glsl';\n\nexport default `precision highp float;\n\n// imports the common uniforms like samplers, and ambient/light color\n${commonUniforms}\n\nuniform vec2 uLightDirection;\n\nvoid main()\n{\n${computeVertexPosition}\n${loadNormals}\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\n\n    // compute Distance\n    float D = length(lightVector);\n\n${computeDiffuse}\n\n    // calculate attenuation\n    float attenuation = 1.0;\n\n${combine}\n}\n`;","import {registerPlugin} from '../../main';\nimport LightShader from '../light/LightShader';\nimport fragment from './directional.frag';\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class DirectionalLightShader extends LightShader {\n    constructor(gl) {\n        super(gl, null, fragment, {\n            // the directional vector of the light\n            uLightDirection: {\n                type: '2f',\n                value: new Float32Array(2)\n            }\n        });\n    }\n}\n\nregisterPlugin('directionalLightShader', DirectionalLightShader);\n","import {plugins, normalGroup, diffuseGroup} from '../main';\n\n/**\n * @class\n * @private\n * @memberof PIXI.lights\n * @extends PIXI.ObjectRenderer\n * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.\n */\nexport default class LightRenderer extends PIXI.ObjectRenderer {\n    constructor(renderer) {\n        super(renderer);\n\n        // the total number of indices in our batch, there are 6 points per quad.\n        const numIndices = LightRenderer.MAX_LIGHTS * 6;\n\n        /**\n         * Holds the indices\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = new Uint16Array(numIndices);\n\n        //TODO this could be a single buffer shared amongst all renderers as we reuse this set up in most renderers\n        for (let i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n            this.indices[i + 0] = j + 0;\n            this.indices[i + 1] = j + 1;\n            this.indices[i + 2] = j + 2;\n            this.indices[i + 3] = j + 0;\n            this.indices[i + 4] = j + 2;\n            this.indices[i + 5] = j + 3;\n        }\n\n        this.shaders = {};\n\n        /**\n         * The current lights in the batch.\n         *\n         * @member {Light[]}\n         */\n        this.lights = [];\n    }\n\n    onContextChange() {\n        this.gl = this.renderer.gl;\n        for (let key in plugins) {\n            this.shaders[key] = new (plugins[key])(this.gl);\n        }\n    }\n\n    /**\n     * Renders the light object.\n     * @private\n     * @param light {Light} the light to render\n     */\n    render(mesh) {\n        let renderer = this.renderer;\n        let gl = renderer.gl;\n\n        this.lights.push(mesh);\n        /**\n         * Prepares all the buffers to render this light.\n         */\n        let glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n        if (!glData) {\n            renderer.bindVao(null);\n\n            glData = {\n                shader: this.shaders[mesh.shaderName],\n                vertexBuffer: PIXI.glCore.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n                indexBuffer: PIXI.glCore.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n                // build the vao object that will render..\n                vao: null,\n                dirty: mesh.dirty\n            };\n\n            // build the vao object that will render..\n            glData.vao = new PIXI.glCore.VertexArrayObject(gl)\n                .addIndex(glData.indexBuffer)\n                .addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0);\n\n            mesh._glDatas[renderer.CONTEXT_UID] = glData;\n        }\n\n        renderer.bindVao(glData.vao);\n\n        if (mesh.useViewportQuad) {\n            mesh.vertices[2] = mesh.vertices[4] = renderer.screen.width;\n            mesh.vertices[5] = mesh.vertices[7] = renderer.screen.height;\n        }\n        glData.vertexBuffer.upload(mesh.vertices);\n\n        if (glData.dirty !== mesh.dirty) {\n            glData.dirty = mesh.dirty;\n            glData.indexBuffer.upload(mesh.indices);\n        }\n    }\n\n    flush() {\n        let diffuseTexture = null,\n            normalTexture = null,\n            lastLayer = null,\n            lastShader = null,\n            renderer = this.renderer;\n\n        for (let i = 0; i < this.lights.length; ++i) {\n            let light = this.lights[i],\n                layer = this.lights[i]._activeParentLayer;\n\n            if (!layer) {\n                continue;\n            }\n\n            if (lastLayer !== layer) {\n                lastLayer = layer;\n                let stage = layer._activeStageParent;\n\n                if (layer.diffuseTexture &&\n                    layer.normalTexture) {\n                    diffuseTexture = layer.diffuseTexture;\n                    normalTexture = layer.normalTexture;\n                }\n                else {\n                    for (let j = 0; j < stage._activeLayers.length; j++) {\n                        let texLayer = stage._activeLayers[j];\n                        if (texLayer.group === normalGroup) {\n                            normalTexture = texLayer.getRenderTexture();\n                        }\n                        if (texLayer.group === diffuseGroup) {\n                            diffuseTexture = texLayer.getRenderTexture();\n                        }\n                    }\n                }\n\n                renderer.bindTexture(diffuseTexture, 0, true);\n                renderer.bindTexture(normalTexture, 1, true);\n            }\n\n            let glData = light._glDatas[renderer.CONTEXT_UID],\n                shader = glData.shader;\n\n            if (lastShader !== shader) {\n                lastShader = shader;\n                renderer.bindShader(shader);\n\n                shader.uniforms.uSampler = 0;\n                shader.uniforms.uNormalSampler = 1;\n\n                let uViewSize = shader.uniforms.uViewSize;\n                uViewSize[0] = renderer.screen.width;\n                uViewSize[1] = renderer.screen.height;\n                shader.uniforms.uViewSize = uViewSize;\n                shader.uniforms.uFlipY = renderer._activeRenderTarget.root ? 1.0 : 0.0;\n            }\n\n            renderer.bindVao(glData.vao);\n\n            light.syncShader(shader);\n            renderer.state.setBlendMode(light.blendMode);\n            shader.uniforms.translationMatrix = light.worldTransform.toArray(true);\n\n            glData.vao.draw(light.drawMode, light.indices.length, 0);\n        }\n\n        this.lights.length = 0;\n    }\n\n    stop() {\n        this.flush();\n    }\n}\n\n/**\n * Maximum number of lights\n * @static\n * @member {number}\n */\nLightRenderer.MAX_LIGHTS = 500;\n\nPIXI.WebGLRenderer.registerPlugin('lights', LightRenderer);\n","import {registerPlugin} from '../../main';\nimport vertex from './wireframe.vert';\nimport fragment from './wireframe.frag';\n\n/**\n * @class\n * @extends PIXI.Shader\n * @memberof PIXI.lights\n * @param shaderManager {ShaderManager} The WebGL shader manager this shader works for.\n */\nexport default class WireframeShader extends PIXI.Shader {\n    constructor(gl) {\n        super(gl, vertex, fragment, {\n            aVertexPosition: 0\n        });\n    }\n}\n\nregisterPlugin('wireframeShader', WireframeShader);\n"],"names":["PIXI","Circle","prototype","getMesh","totalSegments","vertices","indices","Float32Array","Uint16Array","let","seg","Math","PI","indicesIndex","i","index","angle","cos","radius","sin","plugins","diffuseGroup","display","Group","normalGroup","lightGroup","registerPlugin","name","classRef","useRenderTexture","Light","color","brightness","super","this","blendMode","BLEND_MODES","ADD","drawMode","DRAW_MODES","TRIANGLES","dirty","lightHeight","falloff","shaderName","useViewportQuad","_color","_colorRgba","parentGroup","_glDatas","prototypeAccessors","val","utils","hex2rgb","syncShader","shader","uniforms","uUseViewportQuad","uLightColor","uLightHeight","uLightFalloff","_renderWebGL","renderer","setObjectRenderer","lights","render","Container","LightShader","gl","vertexSrc","fragmentSrc","customUniforms","customAttributes","const","translationMatrix","type","value","projectionMatrix","uSampler","uNormalSampler","uViewSize","u","attributes","aVertexPosition","a","defaultVertexSrc","Shader","AmbientLight","AmbientLightShader","fragment","PointLight","Infinity","TRIANGLE_FAN","uLightRadius","computeDiffuse","combine","PointLightShader","DirectionalLight","target","_directionVector","Point","updateTransform","containerUpdateTransform","vec","wt","worldTransform","tx","x","ty","y","len","sqrt","uLightDirection","commonUniforms","computeVertexPosition","loadNormals","DirectionalLightShader","LightRenderer","numIndices","MAX_LIGHTS","j","shaders","onContextChange","key","mesh","push","glData","CONTEXT_UID","bindVao","vertexBuffer","glCore","GLBuffer","createVertexBuffer","STREAM_DRAW","indexBuffer","createIndexBuffer","STATIC_DRAW","vao","VertexArrayObject","addIndex","addAttribute","FLOAT","screen","width","height","upload","flush","diffuseTexture","normalTexture","lastLayer","lastShader","length","light","layer","_activeParentLayer","stage","_activeStageParent","_activeLayers","texLayer","group","getRenderTexture","bindTexture","bindShader","uFlipY","_activeRenderTarget","root","state","setBlendMode","toArray","draw","stop","ObjectRenderer","WebGLRenderer","WireframeShader","vertex"],"mappings":"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"}